"use strict";

function vhost(opt) {
    function builder(moved, domain) {
        for (var i = 0, ii = moved.length; ii > i; i++) moved[i] = expression(moved[i]);
        return {
            reg: moved,
            orig: domain
        };
    }
    function redirect_body(code) {
        var cod = code;
        return function(res, moved, host, url) {
            for (var reg = moved.reg, i = 0, ii = reg.length; ii > i; i++) if (reg[i].test(host)) {
                var to = moved.orig + url;
                return setHeader(res, "Location", to), res.writeHead(cod, {
                    Location: to
                }), res.end(), !0;
            }
            return !1;
        };
    }
    function expression(urls) {
        var url = urls.replace(/http([s]{0,1}):\/\//i, "").replace(/\*/g, "([^.]+)");
        return "^" != url[0] && (url = "^" + url), new RegExp(url, insensitive);
    }
    function strip(moved) {
        return function(req, res, next) {
            redirect(res, moved, req.headers.host, req.url) || next();
        };
    }
    function proxies(domain, moved, proxy) {
        var domainC = domain, proxyC = proxy;
        if (moved) {
            var mvd = moved, rdc = redirect;
            return function(req, res, next) {
                var host = req.headers.host;
                if (domainC.test(host)) return void proxyC.web(req, res);
                if (!rdc(res, mvd, host, req.url)) return next();
            };
        }
        return function(req, res, next) {
            var host = req.headers.host;
            return domainC.test(host) ? proxyC.web(req, res) : next();
        };
    }
    function framework(domain, moved, fw) {
        var domainC = domain, fwC = fw;
        if (moved) {
            var mvd = moved, rdc = redirect;
            return function(req, res, next) {
                var host = req.headers.host;
                if (domainC.test(host)) return fwC(req, res);
                if (!rdc(res, mvd, host, req.url)) return next();
            };
        }
        return function(req, res, next) {
            var host = req.headers.host;
            return domainC.test(host) ? fwC(req, res) : next();
        };
    }
    function dynamics(files) {
        var rdc = redirect, exp = expression, file = require("path").resolve(files), fs = require("fs"), http_proxy = require("http-proxy");
        if (!fs.existsSync(file)) throw new Error(file + " not exists");
        return function(req, res, next) {
            for (var host = req.headers.host, data = JSON.parse(fs.readFileSync(file, "utf8")), i = 0, ii = data.length; ii > i; i++) {
                var moved, d = data[i];
                insensitive = Boolean(d.insensitive) ? "i" : void 0;
                var domain = exp(d.domain.source || d.domain), proxy = http_proxy.createProxyServer(d.proxies);
                if (d.redirect) {
                    if (moved = builder(d.redirect, d.domain.source || d.domain), domain.test(host)) return proxy.web(req, res), 
                    !0;
                    if (rdc(res, moved, host, req.url)) return !0;
                }
                if (domain.test(host)) return proxy.web(req, res), !0;
            }
            return next();
        };
    }
    function statics(files, obj) {
        var file = require("path").resolve(files);
        if (!require("fs").existsSync(file)) throw new Error(file + " not exists");
        var domain, proxy, moved, temp, d = require(file);
        if (insensitive = Boolean(d.insensitive) ? "i" : void 0, obj.domain) domain = obj.domain; else if (domain = d.domain) {
            if ("RegExp" === domain.constructor.name) domain = domain.source; else if ("string" != typeof domain) throw new Error('invalid "domain" argument');
            domain = expression(domain);
        } else if (!d.dynamic) throw new Error('"domain" is required');
        if (obj.moved ? moved = obj.moved : Array.isArray(d.redirect) === !0 && (moved = builder(d.redirect, obj.orig || d.domain.source || d.domain)), 
        (temp = Number(d.redirectStatus)) && (redirect = redirect_body(temp)), d.stripWWW || d.stripOnlyWWW || d.stripHTTP || d.stripHTTPS) {
            if (temp = obj.orig || d.domain.source || d.domain, d.stripHTTP) return strip({
                reg: [ /./ ],
                orig: temp.replace(/http:\/\//i, "https://")
            });
            if (d.stripHTTPS) return strip({
                reg: [ /./ ],
                orig: temp.replace(/https:\/\//i, "http://")
            });
            if (d.stripOnlyWWW) return strip({
                reg: [ /^www./ ],
                orig: temp.replace(/www./i, ".")
            });
            d.stripWWW && ("object" != typeof moved ? moved = {
                reg: [ /^www./ ],
                orig: domain
            } : moved.reg.push(/^www./));
        }
        if (d.dynamic) return dynamics(String(d.dynamic));
        if (obj.framework) return framework(domain, moved, obj.framework);
        if (obj.proxies) return proxies(domain, moved, obj.proxies);
        if (d.proxies && "object" == typeof d.proxies) return proxy = require("http-proxy").createProxyServer(d.proxies), 
        proxies(domain, moved, proxy);
        throw new Error('"framework" or "proxies" are required');
    }
    var insensitive, domain, fw, proxy, moved, temp, redirect = redirect_body(301), options = opt || Object.create(null), next = Object.create(null);
    if (options.framework && "function" == typeof options.framework ? (fw = options.framework, 
    next.framework = fw) : options.proxies && "object" == typeof options.proxies && (proxy = require("http-proxy").createProxyServer(options.proxies), 
    next.proxies = proxy), insensitive = Boolean(options.insensitive) ? "i" : void 0, 
    domain = options.domain) {
        if ("RegExp" === domain.constructor.name) domain = domain.source; else if ("string" != typeof domain) throw new Error('invalid "domain" argument');
        domain = expression(domain), next.domain = domain, next.orig = options.domain.source || options.domain;
    } else if (!options.dynamic && !options["static"]) throw new Error('"domain" is required');
    if (options.file && console.info('top-vhost > "file" option is deprecated'), Array.isArray(options.redirect) === !0 && (moved = builder(options.redirect, options.domain.source || options.domain), 
    next.moved = moved), (temp = Number(options.redirectStatus)) && (redirect = redirect_body(temp)), 
    options.stripWWW || options.stripOnlyWWW || options.stripHTTP || options.stripHTTPS) {
        if (temp = options.domain.source || options.domain, options.stripHTTP) return strip({
            reg: [ /./ ],
            orig: temp.replace(/http:\/\//i, "https://")
        });
        if (options.stripHTTPS) return strip({
            reg: [ /./ ],
            orig: temp.replace(/https:\/\//i, "http://")
        });
        if (options.stripOnlyWWW) return strip({
            reg: [ /^www./ ],
            orig: temp.replace(/www./i, ".")
        });
        options.stripWWW && ("object" != typeof moved ? moved = {
            reg: [ /^www./ ],
            orig: domain
        } : moved.reg.push(/^www./));
    }
    if (options.dynamic) return dynamics(String(options.dynamic));
    if (options["static"]) return statics(String(options["static"]), next);
    if (fw) return framework(domain, moved, fw);
    if (proxy) return proxies(domain, moved, proxy);
    throw new Error('"framework" or "proxies" are required');
}

var setHeader = require("setheaders").setProctedHeader;

module.exports = vhost;
